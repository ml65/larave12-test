# Дополнительные пояснения: Архитектурные и технические решения

## 1. Краткое описание подхода

Проект разработан с фокусом на **максимальную простоту (KISS)** и **чистую архитектуру**. Все решения принимались с учетом принципа "не усложнять без необходимости", при этом обеспечивая масштабируемость и поддерживаемость кода.

## 2. Архитектурные решения

### 2.1. Трехслойная архитектура

**Решение:** Использование слоистой архитектуры `Controller → Service → Repository → Model`

**Обоснование:**
- **Разделение ответственности (SRP)**: Каждый слой имеет четко определенную роль
- **Тестируемость**: Каждый слой можно тестировать независимо
- **Поддерживаемость**: Изменения в одном слое не затрагивают другие
- **Переиспользование**: Бизнес-логика в сервисах может использоваться в разных контроллерах

**Реализация:**
- **Контроллеры** (`app/Http/Controllers/`) — только координация запросов, вызов сервисов, форматирование ответов
- **Сервисы** (`app/Services/`) — вся бизнес-логика (создание заявок, проверка лимитов, обновление статусов)
- **Репозитории** (`app/Repositories/`) — работа с БД (CRUD, фильтрация, статистика)
- **Модели** (`app/Models/`) — структура данных, связи, scopes


### 2.2. Разделение API и Web контроллеров

**Решение:** Отдельные контроллеры для API (`app/Http/Controllers/Api/`) и Web (`app/Http/Controllers/Web/`)


### 2.3. Базовые классы (BaseService, BaseRepository)

**Решение:** Создание базовых классов для сервисов и репозиториев

**Обоснование:**
- **DRY принцип**: Общая функциональность вынесена в базовые классы
- **Единообразие**: Все сервисы/репозитории следуют одной структуре
- **Расширяемость**: Легко добавить общие методы в будущем

**Особенность:** `BaseService` на данный момент пустой, но оставлен для будущего расширения (валидация, логирование и т.д.)

### 2.4. Принципы SOLID

**Single Responsibility Principle (SRP):**
- Каждый класс имеет одну ответственность
- Контроллеры — координация, сервисы — бизнес-логика, репозитории — работа с БД

**Open/Closed Principle (OCP):**
- Фильтрация в репозиториях реализована через метод `applyFilters()` с использованием `match` выражения
- Легко добавить новые фильтры без изменения существующего кода

**Liskov Substitution Principle (LSP):**
- Все репозитории наследуются от `BaseRepository` и могут использоваться взаимозаменяемо
- Все сервисы наследуются от `BaseService`

**Interface Segregation Principle (ISP):**
- Разделение API и Web контроллеров
- Разделение FormRequest для разных операций

**Dependency Inversion Principle (DIP):**
- Контроллеры зависят от абстракций (сервисы, репозитории), а не от конкретных реализаций
- Использование Dependency Injection через конструкторы

## 3. Выбор технологий и библиотек

### 3.1. Laravel 12 + PHP 8.4

### 3.2. spatie/laravel-permission

**Решение:** Использование библиотеки Spatie для управления ролями

**Использование:**
- Роль `manager` для доступа к админ-панели
- Проверка роли через `hasRole('manager')` в middleware и контроллерах

### 3.3. spatie/laravel-medialibrary

**Решение:** Использование библиотеки Spatie для работы с файлами

**Использование:**
- Файлы прикрепляются к заявкам через коллекцию `attachments`
- Автоматическое сохранение оригинальных имен файлов
- Легкий доступ к файлам через `$ticket->getMedia('attachments')`

### 3.4. laravel/sanctum

**Решение:** Использование Laravel Sanctum для API авторизации
**Использование:**
- Токеновая авторизация для API эндпойнтов
- Middleware `auth:sanctum` для защиты маршрутов
- Метод `createToken()` для генерации токенов

### 3.5. jeroennoten/laravel-adminlte

**Решение:** Использование AdminLTE для админ-панели

### 3.6. darkaonline/l5-swagger

**Решение:** Использование L5-Swagger для документации API согласно ТЗ. P.S. использование swagger без автоматизации крайне неудобно в проектах на php

**Использование:**
- Аннотации `#[OA\...]` в контроллерах
- Автоматическая генерация Swagger документации
- Доступ через `/api/documentation`

## 4. Особенности реализации

### 4.1. Виджет обратной связи

**Решение:** Отдельная Blade-страница, встраиваемая через iframe

**Обоснование:**
- **Универсальность**: Виджет можно встроить на любой сайт без интеграции API
- **Изоляция**: Виджет изолирован от родительской страницы (безопасность)
- **Простота интеграции**: Достаточно добавить `<iframe>` на сайт

**Особенности реализации:**
- **AJAX отправка**: Форма отправляется через `fetch()` API без перезагрузки страницы
- **Обработка файлов**: Поддержка множественной загрузки файлов через `FormData`
- **Валидация на клиенте**: HTML5 валидация + серверная валидация
- **Обратная связь**: Сообщения об успехе/ошибке через `postMessage` API для родительской страницы

**Технические детали:**
```javascript
// Отправка через AJAX
const response = await fetch('/api/tickets', {
    method: 'POST',
    body: formData,
});

// Коммуникация с родительской страницей
window.parent.postMessage({
    type: 'ticket-success',
    message: 'Заявка успешно отправлена!',
    data: data
}, '*');
```

### 4.2. Ограничение на создание заявок

**Решение:** Лимит 1 заявка в день с одного контакта (телефон ИЛИ email) согласно ТЗ

**Реализация:**
- Проверка выполняется **до** создания клиента (экономия ресурсов)
- Использование Eloquent `whereHas()` для проверки через связь с клиентами
- Точная проверка по дню (0:00:00 - 23:59:59) через `startOfDay()` и `endOfDay()`


### 4.3. Автоматическое создание клиентов

**Решение:** Клиент создается автоматически при создании заявки, если не существует


### 4.4. Eloquent Scopes для статистики

**Решение:** Использование Eloquent scopes для расчета статистики

**Обоснование:**
- **Переиспользование**: Scopes можно использовать в разных местах
- **Читаемость**: `Ticket::daily()->count()` читается как естественный язык
- **Производительность**: Запросы оптимизированы на уровне БД

**Реализация:**
```php
// В модели Ticket
public function scopeDaily(Builder $query): Builder
{
    return $query->whereDate('created_at', today());
}

// Использование в репозитории
public function getDailyCount(): int
{
    return $this->model->daily()->count();
}
```

**Преимущества:**
- Использование Carbon для работы с датами
- Легко добавить новые периоды (год, квартал и т.д.)
- Код самодокументируемый

### 4.5. API Resources для форматирования ответов

**Решение:** Все API ответы форматируются через API Resources согласно ТЗ

**Обоснование:**
- **Единообразие**: Все ответы имеют одинаковую структуру
- **Гибкость**: Легко изменить формат ответа в одном месте
- **Безопасность**: Контроль над тем, какие данные возвращаются
- **Версионирование**: Легко создать разные версии API Resources

**Реализация:**
- `TicketResource` — форматирование заявки с клиентом
- `TicketStatisticsResource` — форматирование статистики
- `CustomerResource` — форматирование данных клиента


### 4.6. Валидация через FormRequest

**Решение:** Вся валидация выполняется только через FormRequest классы

**Обоснование:**
- **Разделение ответственности**: Валидация отделена от контроллеров
- **Переиспользование**: FormRequest можно использовать в разных контроллерах
- **Тестируемость**: Валидацию можно тестировать отдельно
- **Чистота кода**: Контроллеры не содержат правил валидации

**Реализация:**
- `StoreTicketRequest` — валидация создания заявки (E.164 для телефона)
- `UpdateTicketStatusRequest` — валидация изменения статуса
- `LoginRequest` — валидация авторизации

**Особенности:**
- Валидация телефона в формате E.164 через regex: `/^\+[1-9]\d{1,14}$/`
- Кастомные сообщения об ошибках
- Автоматический возврат 422 при ошибках валидации

### 4.7. Обработка ошибок

**Решение:** Специфичная обработка разных типов исключений

**Обоснование:**
- **Правильные HTTP коды**: Каждый тип ошибки возвращает соответствующий код
- **Информативность**: Пользователь получает понятное сообщение об ошибке
- **Логирование**: Критичные ошибки логируются для анализа

**HTTP коды:**
- `400` — неверные параметры (InvalidArgumentException)
- `422` — ошибки валидации (FormRequest)
- `429` — превышен лимит (RuntimeException)
- `500` — внутренняя ошибка (Exception)

## 5. Технические детали

### 5.1. Строгая типизация

**Решение:** Использование `declare(strict_types=1);` и type hints везде

### 5.2. Dependency Injection

**Решение:** Все зависимости внедряются через конструкторы

**Обоснование:**
- **Тестируемость**: Легко мокировать зависимости в тестах
- **Гибкость**: Легко заменить реализацию
- **Явные зависимости**: Видно, от чего зависит класс

**Реализация:**
```php
public function __construct(
    private readonly TicketService $ticketService,
    private readonly TicketRepository $ticketRepository
) {
}
```

**Преимущества:**
- `readonly` свойства — неизменяемость после инициализации
- Автоматическое разрешение зависимостей Laravel
- Нет необходимости в сервис-локаторе

### 5.3. Middleware для авторизации


### 5.4. Фильтрация в репозиториях

**Решение:** Использование метода `applyFilters()` с `match` выражением

**Обоснование:**
- **Расширяемость**: Легко добавить новые фильтры
- **Читаемость**: `match` более читаем, чем множественные `if`
- **Производительность**: `match` быстрее множественных условий

**Реализация:**
```php
private function applyFilters(Builder $query, array $filters): Builder
{
    foreach ($filters as $key => $value) {
        match ($key) {
            'status' => $query->where('status', $value),
            'date_from' => $query->whereDate('created_at', '>=', $value),
            // ...
        };
    }
    return $query;
}
```

### 5.5. Использование $this->model в репозиториях

**Решение:** Все запросы используют `$this->model` вместо прямых вызовов классов моделей

**Обоснование:**
- **Dependency Inversion**: Репозиторий зависит от абстракции (Model), а не от конкретной модели
- **Тестируемость**: Легко подменить модель в тестах
- **Гибкость**: Можно использовать один репозиторий для разных моделей

**Пример:**
```php
// Плохо (прямая зависимость)
return Ticket::where('status', $status)->get();

// Хорошо (через $this->model)
return $this->model->where('status', $status)->get();
```

## 6. Дополнительные решения

### 6.1. Docker Compose

**Решение:** Настройка Docker Compose для локальной разработки

**Компоненты:**
- PHP-FPM контейнер
- MySQL контейнер
- Nginx контейнер (опционально)

### 6.2. Тестирование

**Решение:** Покрытие критичного функционала тестами

**Обоснование:**
- **Надежность**: Тесты гарантируют, что функционал работает корректно
- **Рефакторинг**: Можно безопасно изменять код, зная что тесты пройдут
- **Документация**: Тесты служат документацией к коду

**Покрытие:**
- Создание заявок через API
- Валидация данных (E.164 формат телефона)
- Ограничение на создание заявок (1 в день)
- Статистика по заявкам
- Изменение статусов заявок

**Технологии:**
- PHPUnit 11.5
- Laravel Testing Framework
- Фабрики для создания тестовых данных

### 6.3. Документация API (Swagger/OpenAPI)

**Решение:** Использование L5-Swagger для автоматической генерации документации

**Реализация:**
- Аннотации `#[OA\...]` в контроллерах
- Автоматическая генерация Swagger JSON
- Доступ через `/api/documentation`


### 6.4. Отсутствие DTO классов

**Решение:** Передача данных через массивы/объекты напрямую

**Обоснование:**
- **KISS принцип**: Не усложнять без необходимости
- **Простота**: Массивы PHP достаточны для MVP
- **Гибкость**: Легко изменить структуру данных

### 6.6. Отсутствие Events/Listeners

**Решение:** Не использовать Events/Listeners на старте

**Обоснование:**
- **KISS принцип**: Текущий функционал не требует событийной архитектуры
- **Простота**: Прямые вызовы методов понятнее для MVP
- **Производительность**: Меньше накладных расходов


## 7. Безопасность

### 7.1. Валидация входных данных

**Решение:** Строгая валидация всех входных данных через FormRequest

**Обоснование:**
- **Защита от инъекций**: Валидация предотвращает SQL-инъекции, XSS
- **Целостность данных**: Гарантия корректности данных в БД
- **Пользовательский опыт**: Понятные сообщения об ошибках

**Реализация:**
- Валидация телефона в формате E.164
- Валидация email
- Ограничение размера файлов (10MB)
- Проверка типов файлов

### 7.2. Авторизация и аутентификация

**Решение:** Разделение авторизации для API (Sanctum) и Web (сессии)

**Обоснование:**
- **Безопасность**: Токены для API, сессии для Web
- **Гибкость**: Разные механизмы для разных протоколов
- **Стандарты**: Соответствие best practices

**Реализация:**
- API: токены через Laravel Sanctum
- Web: сессии Laravel
- Middleware для проверки ролей

### 7.3. Обработка файлов

**Решение:** Использование Spatie MediaLibrary для безопасной работы с файлами

**Обоснование:**
- **Валидация**: Проверка типов и размеров файлов
- **Изоляция**: Файлы хранятся отдельно от кода
- **Метаданные**: Сохранение информации о файлах

## 8. Производительность

### 8.1. Индексы в БД

**Решение:** Индексы на часто используемых полях

**Обоснование:**
- **Скорость запросов**: Быстрый поиск по индексированным полям
- **Масштабируемость**: Система будет работать быстро при росте данных

**Индексированные поля:**
- `customers.phone` — поиск клиентов
- `customers.email` — поиск клиентов
- `tickets.customer_id` — связь с клиентами
- `tickets.status` — фильтрация по статусу
- `tickets.created_at` — фильтрация по дате

### 8.3. Оптимизация запросов

**Решение:** Использование Eloquent scopes и оптимизированных запросов

**Обоснование:**
- **Эффективность**: Запросы оптимизированы на уровне БД
- **Читаемость**: Scopes делают код понятнее

## 9. Заключение

Все архитектурные и технические решения были приняты с учетом принципов **KISS**, **SOLID** и **DRY**. Проект спроектирован для легкого расширения и поддержки, при этом оставаясь простым и понятным. Выбранные библиотеки являются проверенными решениями с активной поддержкой сообщества, что гарантирует долгосрочную поддержку проекта.

